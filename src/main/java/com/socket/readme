产生TCP粘包和拆包问题的主要原因是：
操作系统在发送TCP数据的时候，底层会有一个缓冲区，例如1024个字节大小，
如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；
如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。

============================================================================ 关于锁 ============================================================================
wait 会释放锁，sleep 不会释放锁，但两者都会不再占用CPU资源

synchronized 和 Lock，是可重入锁，synchronized 不能主动释放锁，Lock 可以主动释放锁

锁分公平锁和非公平锁
公平锁：
    表示线程获取锁的顺序是按照加锁的顺序来分配的，及先来先得，先进先出的顺序。
非公平锁：
    表示获取锁的抢占机制，是随机获取锁的，和公平锁不一样的就是先来的不一定能拿到锁，有可能一直拿不到锁。

synchronized 是一种非公平锁
Lock 分为公平锁和非公平锁

父线程，可以通过使用子线程调用join方法，来阻塞在原地等待子线程的执行完成，此时：
（1）如果父线程，发生interrupt，比如父线程主动调用interrupt()方法，会触发join方法处抛interrupt异常
（2）如果子线程，发生interrupt，比如子线程主动调用interrupt()方法，不会触发join方法处抛interrupt异常
