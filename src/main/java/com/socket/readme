产生TCP粘包和拆包问题的主要原因是：
操作系统在发送TCP数据的时候，底层会有一个缓冲区，例如1024个字节大小，
如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；
如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。

============================================================================ 关于锁 ============================================================================
wait 会释放锁，sleep 不会释放锁
synchronized 和 Lock，是可重入锁，synchronized 不能主动释放锁，Lock 可以主动释放锁

锁分公平锁和非公平锁
公平锁：
    表示线程获取锁的顺序是按照加锁的顺序来分配的，及先来先得，先进先出的顺序。
非公平锁：
    表示获取锁的抢占机制，是随机获取锁的，和公平锁不一样的就是先来的不一定能拿到锁，有可能一直拿不到锁。

synchronized 是一种非公平锁
Lock 分为公平锁和非公平锁